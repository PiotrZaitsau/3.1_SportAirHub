const User = require("../models/User"); const Booking = require("../models/Booking"); const Court = require("../models/Court"); const logger = require("../utils/logger"); class AnalyticsService { constructor(io) { this.io = io; this.realtimeStats = { activeUsers: 0, todayBookings: 0, todayRevenue: 0, courtUtilization: {} }; this.initialize(); } async initialize() { try { logger.logInfo("Initializing Analytics Service...", "ANALYTICS"); this.startRealtimeCollection(); logger.logInfo("Analytics Service initialized successfully", "ANALYTICS"); } catch (error) { logger.logError(error, "ANALYTICS_INIT"); } } startRealtimeCollection() { setInterval(async () => { try { await this.updateRealtimeStats(); this.broadcastRealtimeStats(); } catch (error) { logger.logError(`Failed to update real-time stats: ${error.message}`, "ANALYTICS"); } }, 30000); logger.logInfo("Real-time analytics collection started", "ANALYTICS"); } async updateRealtimeStats() { const today = new Date(); today.setHours(0, 0, 0, 0); const tomorrow = new Date(today); tomorrow.setDate(tomorrow.getDate() + 1); try { const todayBookings = await Booking.find({ createdAt: { $gte: today, $lt: tomorrow }, status: { $in: ["confirmed", "completed"] } }); this.realtimeStats.todayBookings = todayBookings.length; this.realtimeStats.todayRevenue = todayBookings.reduce((sum, booking) => sum + booking.totalPrice, 0); const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000); this.realtimeStats.activeUsers = await User.countDocuments({ lastActive: { $gte: yesterday } }); await this.updateCourtUtilization(today, tomorrow); } catch (error) { logger.logError(`Error updating real-time stats: ${error.message}`, "ANALYTICS"); } } async updateCourtUtilization(startDate, endDate) { try { const courts = await Court.find({}); const courtStats = {}; for (const court of courts) { const bookings = await Booking.find({ courtId: court._id, startTime: { $gte: startDate, $lt: endDate }, status: { $in: ["confirmed", "completed"] } }); const totalSlots = 24 * 2; const bookedSlots = bookings.reduce((sum, booking) => sum + (booking.duration / 30), 0); courtStats[court._id] = { name: court.name, utilization: Math.round((bookedSlots / totalSlots) * 100), bookingsCount: bookings.length, revenue: bookings.reduce((sum, booking) => sum + booking.totalPrice, 0) }; } this.realtimeStats.courtUtilization = courtStats; } catch (error) { logger.logError(`Error updating court utilization: ${error.message}`, "ANALYTICS"); } } broadcastRealtimeStats() { this.io.to("admin-room").emit("realtime-stats", this.realtimeStats); } getRealtimeStats() { return this.realtimeStats; } trackUserAction(userId, action, metadata = {}) { try { logger.logDebug(`User action tracked: ${userId} - ${action}`, "ANALYTICS"); if (["booking_created", "subscription_purchased", "pass_purchased"].includes(action)) { this.io.to("admin-room").emit("user-action", { userId, action, metadata, timestamp: new Date() }); } } catch (error) { logger.logError(`Failed to track user action: ${error.message}`, "ANALYTICS"); } } updateUserActivity(userId) { try { User.findByIdAndUpdate(userId, { lastActive: new Date() }).exec(); } catch (error) { logger.logError(`Failed to update user activity: ${error.message}`, "ANALYTICS"); } } } module.exports = AnalyticsService;
