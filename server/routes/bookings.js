const express = require("express"); const QRCode = require("qrcode"); const Booking = require("../models/Booking"); const Court = require("../models/Court"); const User = require("../models/User"); const logger = require("../utils/logger"); const router = express.Router(); router.get("/", async (req, res) => { try { const { page = 1, limit = 10, status, startDate, endDate } = req.query; const query = { userId: req.user.id }; if (status) query.status = status; if (startDate || endDate) { query.startTime = {}; if (startDate) query.startTime.$gte = new Date(startDate); if (endDate) query.startTime.$lte = new Date(endDate); } const bookings = await Booking.find(query).populate("courtId", "name type pricePerHour location").sort({ startTime: -1 }).limit(limit * 1).skip((page - 1) * limit).lean(); const total = await Booking.countDocuments(query); res.json({ success: true, data: { bookings, pagination: { page: parseInt(page), limit: parseInt(limit), total, pages: Math.ceil(total / limit) } } }); } catch (error) { logger.logError(`Get bookings error: ${error.message}`, "BOOKING"); res.status(500).json({ success: false, message: "Ошибка при получении бронирований" }); } }); router.get("/:id", async (req, res) => { try { const booking = await Booking.findById(req.params.id).populate("courtId", "name type pricePerHour location images").populate("userId", "firstName lastName email phone"); if (!booking) { return res.status(404).json({ success: false, message: "Бронирование не найдено" }); } if (booking.userId._id.toString() !== req.user.id && req.user.role !== "admin" && req.user.role !== "manager") { return res.status(403).json({ success: false, message: "Доступ запрещен" }); } res.json({ success: true, data: { booking } }); } catch (error) { logger.logError(`Get booking error: ${error.message}`, "BOOKING"); res.status(500).json({ success: false, message: "Ошибка при получении бронирования" }); } }); router.post("/", async (req, res) => { try { const { courtId, startTime, duration, players, equipment, notes, usePass, paymentMethod } = req.body; if (!courtId || !startTime || !duration) { return res.status(400).json({ success: false, message: "Необходимо указать корт, время начала и продолжительность" }); } const court = await Court.findById(courtId); if (!court) { return res.status(404).json({ success: false, message: "Корт не найден" }); } const startDateTime = new Date(startTime); const endDateTime = new Date(startDateTime.getTime() + duration * 60000); const conflictingBooking = await Booking.findOne({ courtId, status: { $in: ["confirmed", "in_progress"] }, $or: [{ startTime: { $lt: endDateTime }, endTime: { $gt: startDateTime } }] }); if (conflictingBooking) { return res.status(409).json({ success: false, message: "Корт недоступен в указанное время" }); } const user = await User.findById(req.user.id); if (!user) { return res.status(404).json({ success: false, message: "Пользователь не найден" }); } const pricingTier = user.subscription.isActive ? "member" : "guest"; const hourlyRate = court.pricing[pricingTier] || court.pricePerHour; const basePrice = (duration / 60) * hourlyRate; let finalPrice = basePrice; if (court.dynamicPricing.enabled) { const hour = startDateTime.getHours(); const isPeakTime = hour >= court.dynamicPricing.peakHours.start && hour <= court.dynamicPricing.peakHours.end; if (isPeakTime) { finalPrice = basePrice * court.dynamicPricing.peakMultiplier; } } let discount = 0; if (user.loyaltyProgram.level !== "bronze") { const discountRate = user.loyaltyProgram.level === "gold" ? 0.1 : 0.05; discount = finalPrice * discountRate; finalPrice -= discount; } let passUsed = null; if (usePass) { const activePass = user.passes.find(pass => pass.isActive && pass.remainingVisits > 0); if (!activePass) { return res.status(400).json({ success: false, message: "У вас нет активных пропусков" }); } passUsed = activePass._id; finalPrice = 0; } const bookingId = new Date().getTime().toString(); const qrData = { bookingId, courtId, startTime: startDateTime, duration, userId: user._id }; const qrCode = await QRCode.toDataURL(JSON.stringify(qrData)); const booking = new Booking({ userId: req.user.id, courtId, startTime: startDateTime, endTime: endDateTime, duration, totalPrice: finalPrice, originalPrice: basePrice, discount, status: "pending_payment", players: players || [], equipment: equipment || [], notes, qrCode, paymentMethod, passUsed, pricingTier, loyaltyPointsEarned: Math.floor(finalPrice / 10), reminders: { twentyFourHour: false, oneHour: false } }); await booking.save(); if (passUsed) { await User.findOneAndUpdate({ _id: req.user.id, "passes._id": passUsed }, { $inc: { "passes.$.remainingVisits": -1 } }); const updatedUser = await User.findById(req.user.id); const updatedPass = updatedUser.passes.find(p => p._id.toString() === passUsed.toString()); if (updatedPass.remainingVisits === 0) { updatedPass.isActive = false; await updatedUser.save(); } booking.status = "confirmed"; await booking.save(); } if (req.app.locals.analyticsService) { req.app.locals.analyticsService.trackUserAction(req.user.id, "booking_created", { courtId, price: finalPrice, duration, usedPass: !!passUsed }); } if (passUsed && req.app.locals.notificationService) { req.app.locals.notificationService.sendBookingConfirmation(booking._id); } logger.logInfo(`Booking created: ${booking._id} for user ${req.user.id}`, "BOOKING"); res.status(201).json({ success: true, message: "Бронирование создано", data: { booking: { id: booking._id, courtId: booking.courtId, startTime: booking.startTime, endTime: booking.endTime, duration: booking.duration, totalPrice: booking.totalPrice, status: booking.status, qrCode: booking.qrCode, passUsed: !!passUsed } } }); } catch (error) { logger.logError(`Create booking error: ${error.message}`, "BOOKING"); res.status(500).json({ success: false, message: "Ошибка при создании бронирования" }); } }); module.exports = router;
