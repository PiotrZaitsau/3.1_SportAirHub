const express = require("express"); const Court = require("../models/Court"); const Booking = require("../models/Booking"); const logger = require("../utils/logger"); const router = express.Router(); router.get("/", async (req, res) => { try { const { type, available, date } = req.query; const query = { isActive: true }; if (type) query.type = type; const courts = await Court.find(query).select('-maintenanceHistory -__v').sort({ name: 1 }); let availableCourts = courts; if (available === 'true' && date) { const selectedDate = new Date(date); const startOfDay = new Date(selectedDate); startOfDay.setHours(0, 0, 0, 0); const endOfDay = new Date(selectedDate); endOfDay.setHours(23, 59, 59, 999); availableCourts = []; for (const court of courts) { const existingBookings = await Booking.countDocuments({ courtId: court._id, startTime: { $gte: startOfDay, $lte: endOfDay }, status: { $in: ['confirmed', 'in_progress', 'pending_payment'] } }); if (existingBookings < 34) { availableCourts.push(court); } } } res.json({ success: true, data: { courts: availableCourts, total: availableCourts.length } }); } catch (error) { logger.logError(`Get courts error: ${error.message}`, "COURT"); res.status(500).json({ success: false, message: "Ошибка при получении списка кортов" }); } }); router.get("/:id", async (req, res) => { try { const court = await Court.findById(req.params.id).select('-maintenanceHistory -__v'); if (!court) { return res.status(404).json({ success: false, message: "Корт не найден" }); } if (!court.isActive) { return res.status(400).json({ success: false, message: "Корт временно недоступен" }); } res.json({ success: true, data: { court } }); } catch (error) { logger.logError(`Get court error: ${error.message}`, "COURT"); res.status(500).json({ success: false, message: "Ошибка при получении информации о корте" }); } }); router.get("/:id/availability", async (req, res) => { try { const { date, duration = 60 } = req.query; if (!date) { return res.status(400).json({ success: false, message: "Необходимо указать дату" }); } const court = await Court.findById(req.params.id); if (!court || !court.isActive) { return res.status(404).json({ success: false, message: "Корт не найден или недоступен" }); } const selectedDate = new Date(date); const startOfDay = new Date(selectedDate); startOfDay.setHours(6, 0, 0, 0); const endOfDay = new Date(selectedDate); endOfDay.setHours(23, 0, 0, 0); const existingBookings = await Booking.find({ courtId: req.params.id, startTime: { $gte: startOfDay, $lte: endOfDay }, status: { $in: ['confirmed', 'in_progress', 'pending_payment'] } }).select('startTime endTime duration'); const timeSlots = []; const slotDuration = 30; const requestedDuration = parseInt(duration); for (let hour = 6; hour < 23; hour++) { for (let minute = 0; minute < 60; minute += slotDuration) { const slotStart = new Date(selectedDate); slotStart.setHours(hour, minute, 0, 0); const slotEnd = new Date(slotStart); slotEnd.setMinutes(slotEnd.getMinutes() + requestedDuration); const isAvailable = !existingBookings.some(booking => { const bookingStart = new Date(booking.startTime); const bookingEnd = new Date(booking.endTime); return (slotStart < bookingEnd && slotEnd > bookingStart); }); const courtCloses = new Date(selectedDate); courtCloses.setHours(23, 0, 0, 0); if (slotEnd <= courtCloses) { timeSlots.push({ startTime: slotStart, endTime: slotEnd, available: isAvailable, duration: requestedDuration }); } } } res.json({ success: true, data: { courtId: court._id, courtName: court.name, date: selectedDate, requestedDuration, timeSlots, totalSlots: timeSlots.length, availableSlots: timeSlots.filter(slot => slot.available).length } }); } catch (error) { logger.logError(`Check availability error: ${error.message}`, "COURT"); res.status(500).json({ success: false, message: "Ошибка при проверке доступности" }); } }); module.exports = router;
